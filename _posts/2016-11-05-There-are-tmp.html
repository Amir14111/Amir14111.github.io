---
layout: post
title: New interpolation
---
Cортировка подсчётом (англ. Counting sort) — алгоритм сортировки, в котором используется диапазон чисел сортируемого массива (списка) для подсчёта совпадающих элементов. Применение сортировки подсчётом целесообразно лишь тогда, когда сортируемые числа имеют (или их можно отобразить в) диапазон возможных значений, который достаточно мал по сравнению с сортируемым множеством, например, миллион натуральных чисел меньших 1000. Эффективность алгоритма падает, если при попадании нескольких различных элементов в одну ячейку, их надо дополнительно сортировать. Необходимость сортировки внутри ячеек лишает алгоритм смысла[уточнить], так как каждый элемент придётся просматривать более одного раза.

<!DOCTYPE HTML>
<html>
  <head>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js">
MathJax.Hub.Config({
 extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
 jax: ["input/TeX", "output/HTML-CSS"],
 tex2jax: {
     inlineMath: [ ['$','$'], ["\\(","\\)"] ],
     displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
 },
 "HTML-CSS": { availableFonts: ["TeX"] }
});
</script> 

<title>yes</title>

</head>
<body>


Although I knew how to implement an "normal" flat Multilayer Perceptron (MLP), 
I got very confused when trying to implement a CNN. In the end I wanted to 
fully understand the math to understand how to get a working implementation.
*Isn't this just backpropagation as usual?*
Well, basically yes, but a bit more complex and with some pitfalls, so read on.

$$
\delta_{m}^{l}\left(x,\: y\right)=\underbrace{\sum_{o}\sum_{\, x',\, y'}^{N_{w},N_{w}}\delta_{o}^{l+1}\left(x+x',\, y+y'\right)\cdot w_{m,o}^{l+1}\left(x',\, y'\right)}_{\text{Cross-Correlation, Backpropagated Error}}\cdot\frac{\partial a\left(c_{m}^{l}\left(x,\, y\right)\right)}{\partial c_{m}^{l}\left(x,\, y\right)}
$$

Algorithm 


void counting_sort(int* vec, int len, int min, int max)
 2 {
 3 	assert(len > 0);
 4 	assert(min <= max);
 5 	assert(vec != NULL);
 6 
 7 	int * cnt = new int[max-min+1];
 8 
 9 	for (int i = min; i <= max; ++i) {
10 		cnt[i - min] = 0;
11 	}
12 
13 	for (int i = 0; i < len; ++i) {
14 		++cnt[vec[i] - min];
15 	}
16 
17 	for (int i = min; i <= max; ++i) {
18 		for(int j = cnt[i - min]; j--;) {
19 			*vec++ = i;
20 		}
21 	}
22 	delete [] cnt;
23 }




</body>
</html>
